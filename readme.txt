When I first started studying computer science in Paris, I encountered a problem involving data sorting. I successfully sorted the data using the bubble sort algorithm, but I began to wonder if there might be other algorithms for sorting. Through research, I discovered various algorithms for data sorting, particularly the four major sorting algorithms, and I wanted to build upon these ideas further.

Additionally, I wanted to measure the time it took for my code to execute. While writing the code for time measurement, I applied concepts from genetic algorithms to enhance the reusability and efficiency of the code. 

Lorsque j'ai commencé à étudier l'informatique à Paris, j'ai rencontré un problème impliquant le tri de données. J'ai réussi à trier les données en utilisant l'algorithme de tri à bulles, mais je me suis demandé s'il pouvait exister d'autres algorithmes de tri. Après des recherches, j'ai découvert divers algorithmes pour le tri de données, en particulier les quatre principaux algorithmes de tri, et j'ai voulu développer davantage ces idées.

De plus, je souhaitais mesurer le temps d'exécution de mon code. En écrivant le code pour mesurer ce temps, j'ai appliqué des concepts d'algorithmes génétiques afin d'améliorer la réutilisabilité et l'efficacité du code.


처음 파리에서 컴퓨터 공학을 배우면서, 데이터 정렬 문제를 접하게 되었습니다. 버블 정렬을 사용해 데이터를 정렬하는 데 성공했지만, 다른 알고리즘은 없을까 하는 의문이 생겼습니다. 이에 대해 조사해보니, 데이터를 정렬할 수 있는 다양한 알고리즘, 특히 4대 정렬이 있다는 것을 확인하게 되었고, 이를 기반으로 아이디어를 발전시켜 보고 싶었습니다.

또한, 작성한 코드가 실행될 때 걸리는 시간을 측정해 보고 싶었습니다. 시간을 측정하는 코드를 작성하면서 제네틱 알고리즘의 아이디어를 적용해 코드의 재사용성과 효율성을 높이는 데 성공했습니다. 
